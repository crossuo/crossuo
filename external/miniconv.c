/*
	Minimal iconv
	Copyright (c) 2005-2012 Mark H. P. Lord. All rights reserved.
*/

/* For MSC */
#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_NONSTDC_NO_WARNINGS

#include "miniconv.h"
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>

#ifndef FALSE
	#define FALSE 0
#endif

#ifndef TRUE
	#define TRUE 1
#endif

#ifndef COUNTOF
	#define COUNTOF(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define _10000000 0x80
#define _11000000 0xc0
#define _11100000 0xe0
#define _11110000 0xf0
#define _11111000 0xf8
#define _11111100 0xfc
#define _11111110 0xfe
#define _01111111 0x7f
#define _00111111 0x3f
#define _00011111 0x1f
#define _00001111 0x0f
#define _00000111 0x07
#define _00000011 0x03
#define _00000001 0x01

/** @private */
typedef enum {
	MINICONV_MODE_STRICT,
	MINICONV_MODE_DISCARD,
	MINICONV_MODE_TRANSLIT,
} miniconv_mode_t;

/** @private */
typedef struct miniconv_chunk_s {
	struct miniconv_cd_s *cd;
	const char **inbuf;
	size_t *inbytesleft;
	char **outbuf;
	size_t *outbytesleft;
	int error;
} miniconv_chunk_t;

typedef size_t (*miniconv_encoder_t)(miniconv_chunk_t *chunk, miniconv_uint32_t ucs);

typedef size_t (*miniconv_decoder_t)(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder);

/** @private */
typedef struct miniconv_cd_s {
	miniconv_mode_t mode;
	miniconv_encoder_t encoder;
	miniconv_decoder_t decoder;
} miniconv_cd_t;

MINICONV_INLINE int miniconv_unicode_is_valid_code_point(
	miniconv_uint32_t ucs)
{
	#if 1
		if (ucs & 0x80000000)
			return FALSE;
	#else
		if (ucs > 0x10ffff)
			return FALSE;

		/* Surrogate range. */
		if (ucs >= 0xd800 && ucs <= 0xdfff)
			return FALSE;
			
		/* BOM. */
		if (ucs == 0xfffe || ucs == 0xffff)
			return FALSE;
		
		/* I don't check for the non-characters yet. */
		
	#endif
		
	return TRUE;
}

static size_t miniconv_decode_ascii(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 1) {
		size_t enc;
		miniconv_uint32_t ucs = *(const unsigned char *) (*chunk->inbuf);
		
		if (ucs > 0x7f) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		}
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		(*chunk->inbuf) += 1;
		(*chunk->inbytesleft) -= 1;
	}
	
	return retval;
}

static int miniconv_utf8_decode_leading_byte(unsigned int leadingbyte,
	unsigned int *codelen)
{
	if ((leadingbyte & _11100000) == _11000000)
		*codelen = 2;
	else if ((leadingbyte & _11110000) == _11100000)
		*codelen = 3;
	else if ((leadingbyte & _11111000) == _11110000)
		*codelen = 4;
	else if ((leadingbyte & _11111100) == _11111000)
		*codelen = 5;
	else if ((leadingbyte & _11111110) == _11111100)
		*codelen = 6;
	else {
		/* Unknown/invalid. */
		return FALSE;
	}
	
	return TRUE;
}

static int miniconv_utf8_decode_multibyte(const unsigned char *bytes,
	unsigned int codelen, miniconv_uint32_t *ucs)
{
	unsigned int k;
	miniconv_uint32_t c, cmin;
	
	/* Check we have the correct number of trailing bytes. */
	for (k = 1; k != codelen; k++) {
		if ((bytes[k] & _11000000) != _10000000) {
			/* Malformed. */
			return FALSE;
		}
	}

	switch (codelen) {
	case 2:
		c  = ((miniconv_uint32_t) (bytes[0] & _00011111)) <<  6;
		c |= ((miniconv_uint32_t) (bytes[1] & _00111111));
		cmin = 0x00000080;
		break;
	case 3:
		c  = ((miniconv_uint32_t) (bytes[0] & _00001111)) << 12;
		c |= ((miniconv_uint32_t) (bytes[1] & _00111111)) <<  6;
		c |= ((miniconv_uint32_t) (bytes[2] & _00111111));
		cmin = 0x00000800;
		break;
	case 4:
		c  = ((miniconv_uint32_t) (bytes[0] & _00000111)) << 18;
		c |= ((miniconv_uint32_t) (bytes[1] & _00111111)) << 12;
		c |= ((miniconv_uint32_t) (bytes[2] & _00111111)) <<  6;
		c |= ((miniconv_uint32_t) (bytes[3] & _00111111));
		cmin = 0x00010000;
		break;
	case 5:
		c  = ((miniconv_uint32_t) (bytes[0] & _00000011)) << 24;
		c |= ((miniconv_uint32_t) (bytes[1] & _00111111)) << 18;
		c |= ((miniconv_uint32_t) (bytes[2] & _00111111)) << 12;
		c |= ((miniconv_uint32_t) (bytes[3] & _00111111)) <<  6;
		c |= ((miniconv_uint32_t) (bytes[4] & _00111111));
		cmin = 0x00200000;
		break;
	case 6:
		c  = ((miniconv_uint32_t) (bytes[0] & _00000001)) << 30;
		c |= ((miniconv_uint32_t) (bytes[1] & _00111111)) << 24;
		c |= ((miniconv_uint32_t) (bytes[2] & _00111111)) << 18;
		c |= ((miniconv_uint32_t) (bytes[3] & _00111111)) << 12;
		c |= ((miniconv_uint32_t) (bytes[4] & _00111111)) <<  6;
		c |= ((miniconv_uint32_t) (bytes[5] & _00111111));
		cmin = 0x04000000;
		break;
	default:
		return FALSE;
	}
	
	if (c < cmin)
		return FALSE;
		
	*ucs = c;
	return TRUE;
}

static unsigned int miniconv_utf8_code_length(miniconv_uint32_t ucs)
{
	if (ucs < 0x80)
		return 1;
	else if (ucs < 0x00000800)
		return 2;
	else if (ucs < 0x00010000)
		return 3;
	else if (ucs < 0x00200000)
		return 4;
	else if (ucs < 0x04000000)
		return 5;
	else if (ucs < 0x80000000)
		return 6;
		
	return 0;
}

static unsigned int miniconv_utf8_encode_character(miniconv_uint32_t ucs,
	unsigned char *output)
{
	unsigned char *outptr = output;
	
	if (ucs < 0x80) {
		*outptr = (unsigned char) ucs;
		return 1;
	} else if (ucs < 0x00000800) {
		*outptr++ = (unsigned char) (_11000000 | ((ucs >>  6) & _00011111));
		*outptr   = (unsigned char) (_10000000 | ((ucs	    ) & _00111111));
		return 2;
	} else if (ucs < 0x00010000) {
		*outptr++ = (unsigned char) (_11100000 | ((ucs >> 12) & _00001111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >>  6) & _00111111));
		*outptr   = (unsigned char) (_10000000 | ((ucs	    ) & _00111111));
		return 3;
	} else if (ucs < 0x00200000) {
		*outptr++ = (unsigned char) (_11110000 | ((ucs >> 18) & _00000111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 12) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >>  6) & _00111111));
		*outptr   = (unsigned char) (_10000000 | ((ucs	    ) & _00111111));
		return 4;
	} else if (ucs < 0x04000000) {
		*outptr++ = (unsigned char) (_11111000 | ((ucs >> 24) & _00000011));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 18) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 12) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >>  6) & _00111111));
		*outptr   = (unsigned char) (_10000000 | ((ucs	    ) & _00111111));
		return 5;
	} else if (ucs < 0x80000000) {
		*outptr++ = (unsigned char) (_11111100 | ((ucs >> 30) & _00000001));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 24) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 18) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >> 12) & _00111111));
		*outptr++ = (unsigned char) (_10000000 | ((ucs >>  6) & _00111111));
		*outptr   = (unsigned char) (_10000000 | ((ucs	    ) & _00111111));
		return 6;
	} else {
		assert(0);
		return 0;
	}
}

/* Returns TRUE if the specifeid byte is a UTF-8 trailing byte. */
MINICONV_INLINE int miniconv_utf8_is_trailing_byte(unsigned int test)
{
	return (test & _11000000) == _10000000;
}

/* Returns TRUE if the specified byte is ASCII under UTF-8 encoding. */
MINICONV_INLINE int miniconv_utf8_is_ascii_byte(unsigned int test)
{
	return (test & _10000000) == 0;
}

/* Returns TRUE if the specified byte is a UTF-8 leading byte. */
/*MINICONV_INLINE int miniconv_utf8_is_leading_byte(unsigned int test)
{
	return ! miniconv_utf8_is_trailing_byte(test)
		&& ! miniconv_utf8_is_ascii_byte(test);
}*/

static size_t miniconv_decode_utf8(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 1) {
		const unsigned char *in;
		miniconv_uint32_t ucs;
		unsigned int length;
		size_t enc;
		
		in = (const unsigned char *) *chunk->inbuf;
		
		if (miniconv_utf8_is_trailing_byte(in[0])) {
			/* Unexpected trailing byte. */
			goto invalid_sequence;
		}
		
		if (miniconv_utf8_is_ascii_byte(in[0])) {
			ucs = in[0];
			length = 1;
		} else {
			if (! miniconv_utf8_decode_leading_byte(in[0], &length)) {
				/* Invalid leading byte. */
				goto invalid_sequence;
			}
			
			if (*chunk->inbytesleft < length) {
				/* No room for the full code. */
				chunk->error = EINVAL;
				return (size_t) -1;
			}
			
			if (! miniconv_utf8_decode_multibyte(in, length, &ucs)
					|| ! miniconv_unicode_is_valid_code_point(ucs)) {
				goto invalid_sequence;
			}
		}
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		(*chunk->inbuf) += length;
		(*chunk->inbytesleft) -= length;
		
		continue;
		
	invalid_sequence:

		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		}
		
		/* Skip the byte. */
		(*chunk->inbuf) += 1;
		(*chunk->inbytesleft) -= 1;
	}
	
	return retval;
}

static size_t miniconv_decode_ucs1(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 1) {
		size_t enc;
		miniconv_uint32_t ucs = *(const unsigned char *) (*chunk->inbuf);
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		(*chunk->inbuf) += 1;
		(*chunk->inbytesleft) -= 1;
	}
	
	return retval;
}

static size_t miniconv_decode_ucs2le(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 2) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (in[0]);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[1]) << 8);
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 2);
		(*chunk->inbytesleft) -= 2;
	}

	return retval;
}

static size_t miniconv_decode_ucs2be(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 2) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (((miniconv_uint32_t) in[0]) << 8);
		ucs |= (miniconv_uint32_t) (in[1]);
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 2);
		(*chunk->inbytesleft) -= 2;
	}
	
	return retval;
}

MINICONV_INLINE int miniconv_utf16_is_leading_word(unsigned int test)
{
	return (test >= 0xd800 && test <= 0xdbff);
}

MINICONV_INLINE int miniconv_utf16_is_trailing_word(unsigned int test)
{
	return (test > 0xdbff && test <= 0xdfff);
}

static size_t miniconv_decode_utf16(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder, int littleendian)
{
	int lowbyte, highbyte, lowbyte2, highbyte2;
	size_t retval = 0;
	
	if (littleendian) {
		lowbyte = 0;
		highbyte = 1;
	} else {
		lowbyte = 1;
		highbyte = 0;
	}
	
	lowbyte2 = lowbyte + 2;
	highbyte2 = highbyte + 2;
	
	while (*chunk->inbytesleft >= 2) {
		size_t enc;
		miniconv_uint32_t ucs;
		size_t advance;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);

		ucs = (miniconv_uint32_t) (in[lowbyte]);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[highbyte]) << 8);
		
		if (miniconv_utf16_is_leading_word((miniconv_uint16_t) ucs)) {
			miniconv_uint16_t w2;
			
			if (*chunk->inbytesleft < 4)
				break;
			
			w2 = (miniconv_uint16_t) in[lowbyte2];
			w2 |= (miniconv_uint16_t) (((miniconv_uint16_t) in[highbyte2]) << 8);
			
			if (! miniconv_utf16_is_trailing_word(w2)) {
				if (chunk->cd->mode == MINICONV_MODE_STRICT) {
					chunk->error = EILSEQ;
					return (size_t) -1;
				}
				
				/* Skip the leading word */
				(*chunk->inbuf) += 2;
				(*chunk->inbytesleft) += 2;
				
				continue;
			}
			
			ucs = ((miniconv_uint32_t) ucs & 0x3ff) << 10;
			ucs |= ((miniconv_uint32_t) w2 & 0x3ff);
			ucs += 0x10000;
			
			advance = 4;
		} else {
			advance = 2;
		}

		if (! miniconv_unicode_is_valid_code_point(ucs)) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		}

		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
			
		(*chunk->inbuf) += advance;
		(*chunk->inbytesleft) -= advance;
	}

	return retval;
}

static size_t miniconv_decode_utf16le(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	return miniconv_decode_utf16(chunk, encoder, TRUE);
}

static size_t miniconv_decode_utf16be(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	return miniconv_decode_utf16(chunk, encoder, FALSE);
}

static size_t miniconv_decode_ucs4le(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 4) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (in[0]);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[1]) << 8);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[2]) << 16);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[3]) << 24);
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 4);
		(*chunk->inbytesleft) -= 4;
	}
	
	return retval;
}

static size_t miniconv_decode_ucs4be(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 4) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (((miniconv_uint32_t) in[0]) << 24);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[1]) << 16);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[2]) << 8);
		ucs |= (miniconv_uint32_t) (in[3]);
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 4);
		(*chunk->inbytesleft) -= 4;
	}
	
	return retval;
}

static size_t miniconv_decode_utf32le(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 4) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (in[0]);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[1]) << 8);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[2]) << 16);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[3]) << 24);
		
		if (! miniconv_unicode_is_valid_code_point(ucs)) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		}
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 4);
		(*chunk->inbytesleft) -= 4;
	}
	
	return retval;
}

static size_t miniconv_decode_utf32be(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft >= 4) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = (miniconv_uint32_t) (((miniconv_uint32_t) in[0]) << 24);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[1]) << 16);
		ucs |= (miniconv_uint32_t) (((miniconv_uint32_t) in[2]) << 8);
		ucs |= (miniconv_uint32_t) (in[3]);

		if (! miniconv_unicode_is_valid_code_point(ucs)) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		}
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;

		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 4);
		(*chunk->inbytesleft) -= 4;
	}
	
	return retval;
}

static size_t miniconv_decode_8bit_codepage(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder, const miniconv_uint16_t *codepage)
{
	size_t retval = 0;
	
	while (*chunk->inbytesleft) {
		size_t enc;
		miniconv_uint32_t ucs;
		const unsigned char *in = (const unsigned char *) (*chunk->inbuf);
		
		ucs = codepage[*in];
		
		enc = (*encoder)(chunk, ucs);
		
		if (enc == (size_t) -1)
			return (size_t) -1;
			
		retval += enc;
		
		*chunk->inbuf = (const char *) (in + 1);
		(*chunk->inbytesleft) -= 1;
	}
	
	return retval;
}

static size_t miniconv_decode_iso_8859_2(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_2[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7, 
		0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 
		0x017b, 0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 
		0x015b, 0x02c7, 0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 
		0x02dd, 0x017e, 0x017c, 0x0154, 0x00c1, 0x00c2, 0x0102, 
		0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 
		0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e, 0x0110, 0x0143, 
		0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 
		0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df, 
		0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 
		0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 
		0x00ee, 0x010f, 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 
		0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 
		0x00fc, 0x00fd, 0x0163, 0x02d9, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_2);
}

static size_t miniconv_decode_iso_8859_3(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_3[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0126, 0x02d8, 0x00a3, 0x00a4, 0x0000, 0x0124, 0x00a7, 
		0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0x0000, 
		0x017b, 0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x0125, 0x00b7, 0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 
		0x00bd, 0x0000, 0x017c, 0x00c0, 0x00c1, 0x00c2, 0x0000, 
		0x00c4, 0x010a, 0x0108, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x0000, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7, 0x011c, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x0000, 0x00e4, 0x010b, 0x0109, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x0000, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x0121, 0x00f6, 0x00f7, 0x011d, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x016d, 0x015d, 0x02d9, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_3);
}

static size_t miniconv_decode_iso_8859_4(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_4[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7, 
		0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 
		0x00af, 0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 
		0x013c, 0x02c7, 0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 
		0x014a, 0x017e, 0x014b, 0x0100, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x012e, 0x010c, 0x00c9, 0x0118, 
		0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a, 0x0110, 0x0145, 
		0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 
		0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df, 
		0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x012f, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 
		0x00ee, 0x012b, 0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 
		0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x0173, 0x00fa, 0x00fb, 
		0x00fc, 0x0169, 0x016b, 0x02d9, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_4);
}

static size_t miniconv_decode_iso_8859_5(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_5[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, 
		0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 
		0x040f, 0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 
		0x0416, 0x0417, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 
		0x041d, 0x041e, 0x041f, 0x0420, 0x0421, 0x0422, 0x0423, 
		0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042a, 
		0x042b, 0x042c, 0x042d, 0x042e, 0x042f, 0x0430, 0x0431, 
		0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 
		0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f, 
		0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 
		0x0447, 0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 
		0x044e, 0x044f, 0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 
		0x0455, 0x0456, 0x0457, 0x0458, 0x0459, 0x045a, 0x045b, 
		0x045c, 0x00a7, 0x045e, 0x045f, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_5);
}

static size_t miniconv_decode_iso_8859_6(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_6[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0000, 0x0000, 0x0000, 0x00a4, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x060c, 0x00ad, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x061b, 0x0000, 
		0x0000, 0x0000, 0x061f, 0x0000, 0x0621, 0x0622, 0x0623, 
		0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629, 0x062a, 
		0x062b, 0x062c, 0x062d, 0x062e, 0x062f, 0x0630, 0x0631, 
		0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 
		0x0639, 0x063a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 
		0x0647, 0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 
		0x064e, 0x064f, 0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_6);
}

static size_t miniconv_decode_iso_8859_7(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_7[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x2018, 0x2019, 0x00a3, 0x20ac, 0x20af, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x037a, 0x00ab, 0x00ac, 0x00ad, 0x0000, 
		0x2015, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 
		0x0386, 0x00b7, 0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 
		0x00bd, 0x038e, 0x038f, 0x0390, 0x0391, 0x0392, 0x0393, 
		0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039a, 
		0x039b, 0x039c, 0x039d, 0x039e, 0x039f, 0x03a0, 0x03a1, 
		0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7, 0x03a8, 
		0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af, 
		0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 
		0x03b7, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 
		0x03be, 0x03bf, 0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 
		0x03c5, 0x03c6, 0x03c7, 0x03c8, 0x03c9, 0x03ca, 0x03cb, 
		0x03cc, 0x03cd, 0x03ce, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_7);
}

static size_t miniconv_decode_iso_8859_8(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_8[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0000, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017, 
		0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 
		0x05d7, 0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 
		0x05de, 0x05df, 0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 
		0x05e5, 0x05e6, 0x05e7, 0x05e8, 0x05e9, 0x05ea, 0x0000, 
		0x0000, 0x200e, 0x200f, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_8);
}

static size_t miniconv_decode_iso_8859_9(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_9[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x011e, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x0131, 0x015f, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_9);
}

static size_t miniconv_decode_iso_8859_10(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_10[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7, 
		0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 
		0x014a, 0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 
		0x0137, 0x00b7, 0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 
		0x2015, 0x016b, 0x014b, 0x0100, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x012e, 0x010c, 0x00c9, 0x0118, 
		0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf, 0x00d0, 0x0145, 
		0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168, 0x00d8, 
		0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, 
		0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x012f, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 
		0x00ee, 0x00ef, 0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x0169, 0x00f8, 0x0173, 0x00fa, 0x00fb, 
		0x00fc, 0x00fd, 0x00fe, 0x0138, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_10);
}

static size_t miniconv_decode_iso_8859_11(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_11[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07, 
		0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 
		0x0e0f, 0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 
		0x0e16, 0x0e17, 0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 
		0x0e1d, 0x0e1e, 0x0e1f, 0x0e20, 0x0e21, 0x0e22, 0x0e23, 
		0x0e24, 0x0e25, 0x0e26, 0x0e27, 0x0e28, 0x0e29, 0x0e2a, 
		0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f, 0x0e30, 0x0e31, 
		0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37, 0x0e38, 
		0x0e39, 0x0e3a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0e3f, 
		0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 
		0x0e47, 0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 
		0x0e4e, 0x0e4f, 0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 
		0x0e55, 0x0e56, 0x0e57, 0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 
		0x0000, 0x0000, 0x0000, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_11);
}

static size_t miniconv_decode_iso_8859_13(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_13[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7, 
		0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00c6, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 
		0x00b6, 0x00b7, 0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00e6, 0x0104, 0x012e, 0x0100, 0x0106, 
		0x00c4, 0x00c5, 0x0118, 0x0112, 0x010c, 0x00c9, 0x0179, 
		0x0116, 0x0122, 0x0136, 0x012a, 0x013b, 0x0160, 0x0143, 
		0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7, 0x0172, 
		0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df, 
		0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 
		0x0113, 0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 
		0x012b, 0x013c, 0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 
		0x00f5, 0x00f6, 0x00f7, 0x0173, 0x0142, 0x015b, 0x016b, 
		0x00fc, 0x017c, 0x017e, 0x2019, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_13);
}

static size_t miniconv_decode_iso_8859_14(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_14[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7, 
		0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 
		0x0178, 0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 
		0x00b6, 0x1e56, 0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 
		0x1e84, 0x1e85, 0x1e61, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x0174, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x1e6b, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x00fd, 0x0177, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_14);
}

static size_t miniconv_decode_iso_8859_15(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_15[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7, 
		0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 
		0x00b6, 0x00b7, 0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 
		0x0153, 0x0178, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x00d0, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x00fd, 0x00fe, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_15);
}

static size_t miniconv_decode_iso_8859_16(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t ISO_8859_16[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 
		0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008a, 0x008b, 
		0x008c, 0x008d, 0x008e, 0x008f, 0x0090, 0x0091, 0x0092, 
		0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 
		0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, 0x00a0, 
		0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7, 
		0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 
		0x017b, 0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 
		0x00b6, 0x00b7, 0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 
		0x0153, 0x0178, 0x017c, 0x00c0, 0x00c1, 0x00c2, 0x0102, 
		0x00c4, 0x0106, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x0110, 0x0143, 
		0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a, 0x0170, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 
		0x0151, 0x00f6, 0x015b, 0x0171, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x0119, 0x021b, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, ISO_8859_16);
}

static size_t miniconv_decode_windows_cp874(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP874[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x2026, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x0000, 0x0000, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00a0, 
		0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07, 
		0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 
		0x0e0f, 0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 
		0x0e16, 0x0e17, 0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 
		0x0e1d, 0x0e1e, 0x0e1f, 0x0e20, 0x0e21, 0x0e22, 0x0e23, 
		0x0e24, 0x0e25, 0x0e26, 0x0e27, 0x0e28, 0x0e29, 0x0e2a, 
		0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f, 0x0e30, 0x0e31, 
		0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37, 0x0e38, 
		0x0e39, 0x0e3a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0e3f, 
		0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 
		0x0e47, 0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 
		0x0e4e, 0x0e4f, 0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 
		0x0e55, 0x0e56, 0x0e57, 0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 
		0x0000, 0x0000, 0x0000, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP874);
}

static size_t miniconv_decode_windows_cp1250(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1250[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0000, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0160, 0x2039, 
		0x015a, 0x0164, 0x017d, 0x0179, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 
		0x0161, 0x203a, 0x015b, 0x0165, 0x017e, 0x017a, 0x00a0, 
		0x02c7, 0x02d8, 0x0141, 0x00a4, 0x0104, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x015e, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x017b, 0x00b0, 0x00b1, 0x02db, 0x0142, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x0105, 0x015f, 0x00bb, 0x013d, 
		0x02dd, 0x013e, 0x017c, 0x0154, 0x00c1, 0x00c2, 0x0102, 
		0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 
		0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e, 0x0110, 0x0143, 
		0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 
		0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df, 
		0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 
		0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 
		0x00ee, 0x010f, 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 
		0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 
		0x00fc, 0x00fd, 0x0163, 0x02d9, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1250);
}

static size_t miniconv_decode_windows_cp1251(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1251[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x0402, 0x0403, 0x201a, 0x0453, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x20ac, 0x2030, 0x0409, 0x2039, 
		0x040a, 0x040c, 0x040b, 0x040f, 0x0452, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 
		0x0459, 0x203a, 0x045a, 0x045c, 0x045b, 0x045f, 0x00a0, 
		0x040e, 0x045e, 0x0408, 0x00a4, 0x0490, 0x00a6, 0x00a7, 
		0x0401, 0x00a9, 0x0404, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x0407, 0x00b0, 0x00b1, 0x0406, 0x0456, 0x0491, 0x00b5, 
		0x00b6, 0x00b7, 0x0451, 0x2116, 0x0454, 0x00bb, 0x0458, 
		0x0405, 0x0455, 0x0457, 0x0410, 0x0411, 0x0412, 0x0413, 
		0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041a, 
		0x041b, 0x041c, 0x041d, 0x041e, 0x041f, 0x0420, 0x0421, 
		0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 
		0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f, 
		0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 
		0x0437, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 
		0x043e, 0x043f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 
		0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044a, 0x044b, 
		0x044c, 0x044d, 0x044e, 0x044f, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1251);
}

static size_t miniconv_decode_windows_cp1252(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1252[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0160, 0x2039, 
		0x0152, 0x0000, 0x017d, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x02dc, 0x2122, 
		0x0161, 0x203a, 0x0153, 0x0000, 0x017e, 0x0178, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x00d0, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x00fd, 0x00fe, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1252);
}

static size_t miniconv_decode_windows_cp1253(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1253[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0000, 0x2039, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 
		0x0000, 0x203a, 0x0000, 0x0000, 0x0000, 0x0000, 0x00a0, 
		0x0385, 0x0386, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x0000, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x2015, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x00b5, 
		0x00b6, 0x00b7, 0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 
		0x00bd, 0x038e, 0x038f, 0x0390, 0x0391, 0x0392, 0x0393, 
		0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039a, 
		0x039b, 0x039c, 0x039d, 0x039e, 0x039f, 0x03a0, 0x03a1, 
		0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7, 0x03a8, 
		0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af, 
		0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 
		0x03b7, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 
		0x03be, 0x03bf, 0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 
		0x03c5, 0x03c6, 0x03c7, 0x03c8, 0x03c9, 0x03ca, 0x03cb, 
		0x03cc, 0x03cd, 0x03ce, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1253);
}

static size_t miniconv_decode_windows_cp1254(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1254[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0160, 0x2039, 
		0x0152, 0x0000, 0x0000, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x02dc, 0x2122, 
		0x0161, 0x203a, 0x0153, 0x0000, 0x0000, 0x0178, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, 0x011e, 0x00d1, 
		0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 
		0x00ee, 0x00ef, 0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 
		0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x0131, 0x015f, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1254);
}

static size_t miniconv_decode_windows_cp1255(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1255[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0000, 0x2039, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x02dc, 0x2122, 
		0x0000, 0x203a, 0x0000, 0x0000, 0x0000, 0x0000, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x20aa, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00bf, 0x05b0, 0x05b1, 0x05b2, 0x05b3, 
		0x05b4, 0x05b5, 0x05b6, 0x05b7, 0x05b8, 0x05b9, 0x0000, 
		0x05bb, 0x05bc, 0x05bd, 0x05be, 0x05bf, 0x05c0, 0x05c1, 
		0x05c2, 0x05c3, 0x05f0, 0x05f1, 0x05f2, 0x05f3, 0x05f4, 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
		0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 
		0x05d7, 0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 
		0x05de, 0x05df, 0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 
		0x05e5, 0x05e6, 0x05e7, 0x05e8, 0x05e9, 0x05ea, 0x0000, 
		0x0000, 0x200e, 0x200f, 0x0000, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1255);
}

static size_t miniconv_decode_windows_cp1256(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1256[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x067e, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0679, 0x2039, 
		0x0152, 0x0686, 0x0698, 0x0688, 0x06af, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x06a9, 0x2122, 
		0x0691, 0x203a, 0x0153, 0x200c, 0x200d, 0x06ba, 0x00a0, 
		0x060c, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x06be, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x061b, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x061f, 0x06c1, 0x0621, 0x0622, 0x0623, 
		0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629, 0x062a, 
		0x062b, 0x062c, 0x062d, 0x062e, 0x062f, 0x0630, 0x0631, 
		0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x00d7, 0x0637, 
		0x0638, 0x0639, 0x063a, 0x0640, 0x0641, 0x0642, 0x0643, 
		0x00e0, 0x0644, 0x00e2, 0x0645, 0x0646, 0x0647, 0x0648, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x0649, 0x064a, 
		0x00ee, 0x00ef, 0x064b, 0x064c, 0x064d, 0x064e, 0x00f4, 
		0x064f, 0x0650, 0x00f7, 0x0651, 0x00f9, 0x0652, 0x00fb, 
		0x00fc, 0x200e, 0x200f, 0x06d2, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1256);
}

static size_t miniconv_decode_windows_cp1257(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1257[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0000, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x0000, 0x2030, 0x0000, 0x2039, 
		0x0000, 0x00a8, 0x02c7, 0x00b8, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x0000, 0x2122, 
		0x0000, 0x203a, 0x0000, 0x00af, 0x02db, 0x0000, 0x00a0, 
		0x0000, 0x00a2, 0x00a3, 0x00a4, 0x0000, 0x00a6, 0x00a7, 
		0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00c6, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00e6, 0x0104, 0x012e, 0x0100, 0x0106, 
		0x00c4, 0x00c5, 0x0118, 0x0112, 0x010c, 0x00c9, 0x0179, 
		0x0116, 0x0122, 0x0136, 0x012a, 0x013b, 0x0160, 0x0143, 
		0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7, 0x0172, 
		0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df, 
		0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 
		0x0113, 0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 
		0x012b, 0x013c, 0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 
		0x00f5, 0x00f6, 0x00f7, 0x0173, 0x0142, 0x015b, 0x016b, 
		0x00fc, 0x017c, 0x017e, 0x02d9, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1257);
}

static size_t miniconv_decode_windows_cp1258(miniconv_chunk_t *chunk,
	miniconv_encoder_t encoder)
{
	static const miniconv_uint16_t WINDOWS_CP1258[256] = {
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 
		0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 
		0x000e, 0x000f, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 
		0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 
		0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 
		0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 
		0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 
		0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 
		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 
		0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 
		0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 
		0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 
		0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 
		0x005b, 0x005c, 0x005d, 0x005e, 0x005f, 0x0060, 0x0061, 
		0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 
		0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 
		0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 
		0x007e, 0x007f, 0x20ac, 0x0000, 0x201a, 0x0192, 0x201e, 
		0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0000, 0x2039, 
		0x0152, 0x0000, 0x0000, 0x0000, 0x0000, 0x2018, 0x2019, 
		0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0x02dc, 0x2122, 
		0x0000, 0x203a, 0x0153, 0x0000, 0x0000, 0x0178, 0x00a0, 
		0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 
		0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 
		0x00af, 0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 
		0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 
		0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x0102, 
		0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 
		0x00cb, 0x0300, 0x00cd, 0x00ce, 0x00cf, 0x0110, 0x00d1, 
		0x0309, 0x00d3, 0x00d4, 0x01a0, 0x00d6, 0x00d7, 0x00d8, 
		0x00d9, 0x00da, 0x00db, 0x00dc, 0x01af, 0x0303, 0x00df, 
		0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x00e5, 0x00e6, 
		0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x0301, 0x00ed, 
		0x00ee, 0x00ef, 0x0111, 0x00f1, 0x0323, 0x00f3, 0x00f4, 
		0x01a1, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 
		0x00fc, 0x01b0, 0x20ab, 0x00ff, 
	};
	
	return miniconv_decode_8bit_codepage(chunk, encoder, WINDOWS_CP1258);
}

static size_t miniconv_encode_ascii(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	if (ucs > 0x7f) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (*chunk->outbytesleft < 1) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	*(unsigned char *) *chunk->outbuf = (unsigned char) (ucs & 0xff);
	
	(*chunk->outbuf) += 1;
	(*chunk->outbytesleft) -= 1;
		
	return 0;
}

static size_t miniconv_encode_utf8(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned int length;
	#ifndef NDEBUG
		unsigned int encodedlen;
	#endif
	
	if (! miniconv_unicode_is_valid_code_point(ucs)) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	length = miniconv_utf8_code_length(ucs);
	
	if (length > *chunk->outbytesleft) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}

	#ifndef NDEBUG
		encodedlen = miniconv_utf8_encode_character(ucs,
			(unsigned char *) *chunk->outbuf);
		
		assert(encodedlen == length);
	#else
		miniconv_utf8_encode_character(ucs, (unsigned char *) *chunk->outbuf);
	#endif
	
	(*chunk->outbuf) += length;
	(*chunk->outbytesleft) -= length;
	
	return 0;
}

static size_t miniconv_encode_ucs1(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	if (ucs > 0xff) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (*chunk->outbytesleft < 1) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	*(unsigned char *) *chunk->outbuf = (unsigned char) (ucs & 0xff);
	
	(*chunk->outbuf) += 1;
	(*chunk->outbytesleft) -= 1;
		
	return 0;
}

static size_t miniconv_encode_ucs2le(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned char *out;
	
	if (ucs > 0xffff) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (*chunk->outbytesleft < 2) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) (ucs & 0xff);
	out[1] = (unsigned char) ((ucs >> 8) & 0xff);
	
	(*chunk->outbuf) += 2;
	(*chunk->outbytesleft) -= 2;
		
	return 0;
}

static size_t miniconv_encode_ucs2be(miniconv_chunk_t *chunk,
		miniconv_uint32_t ucs)
{
	unsigned char *out;
	
	if (ucs > 0xffff) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (*chunk->outbytesleft < 2) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) ((ucs >> 8) & 0xff);
	out[1] = (unsigned char) (ucs & 0xff);
	
	(*chunk->outbuf) += 2;
	(*chunk->outbytesleft) -= 2;
		
	return 0;
}

static int miniconv_utf16_can_represent(miniconv_uint32_t ucs)
{
	if (ucs > 0x10fffd)
		return FALSE;

	/* Surrogate range. */
	if (ucs >= 0xd800 && ucs <= 0xdfff)
		return FALSE;

	return miniconv_unicode_is_valid_code_point(ucs);
}

static size_t miniconv_encode_utf16(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs, int littleendian)
{
	unsigned char *out;
	
	if (! miniconv_utf16_can_represent(ucs)) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (ucs >= 0x10000) {
		miniconv_uint32_t v, vh, vl;
		miniconv_uint16_t w1, w2;
		
		if (*chunk->outbytesleft < 4) {
			chunk->error = E2BIG;
			return (size_t) -1;
		}

		v = ucs - 0x10000;
		vh = (v >> 10); /* High 10 bits. */
		vl = (v & 0x3ff); /* Low 10 bits. */
		w1 = (miniconv_uint16_t) (0xd800 | vh);
		w2 = (miniconv_uint16_t) (0xdc00 | vl);
		
		out = (unsigned char *) *chunk->outbuf;
		
		if (littleendian) {
			out[0] = (unsigned char) (w1 & 0xff);
			out[1] = (unsigned char) ((w1 >> 8) & 0xff);
			out[2] = (unsigned char) (w2 & 0xff);
			out[3] = (unsigned char) ((w2 >> 8) & 0xff);
		} else {
			out[0] = (unsigned char) ((w1 >> 8) & 0xff);
			out[1] = (unsigned char) (w1 & 0xff);
			out[2] = (unsigned char) ((w2 >> 8) & 0xff);
			out[3] = (unsigned char) (w2 & 0xff);
		}
		
		(*chunk->outbuf) += 4;
		(*chunk->outbytesleft) -= 4;
	} else {
		if (*chunk->outbytesleft < 2) {
			chunk->error = E2BIG;
			return (size_t) -1;
		}
		
		out = (unsigned char *) *chunk->outbuf;

		if (littleendian) {
			out[0] = (unsigned char) (ucs & 0xff);
			out[1] = (unsigned char) ((ucs >> 8) & 0xff);
		} else {
			out[0] = (unsigned char) ((ucs >> 8) & 0xff);
			out[1] = (unsigned char) (ucs & 0xff);
		}
		
		(*chunk->outbuf) += 2;
		(*chunk->outbytesleft) -= 2;
	}
	
	return 0;
}

static size_t miniconv_encode_utf16le(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	return miniconv_encode_utf16(chunk, ucs, TRUE);
}

static size_t miniconv_encode_utf16be(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	return miniconv_encode_utf16(chunk, ucs, FALSE);
}

static size_t miniconv_encode_ucs4le(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned char *out;

	if (*chunk->outbytesleft < 4) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) (ucs & 0xff);
	out[1] = (unsigned char) ((ucs >> 8) & 0xff);
	out[2] = (unsigned char) ((ucs >> 16) & 0xff);
	out[3] = (unsigned char) ((ucs >> 24) & 0xff);
	
	(*chunk->outbuf) += 4;
	(*chunk->outbytesleft) -= 4;
		
	return 0;
}

static size_t miniconv_encode_ucs4be(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned char *out;
	
	if (*chunk->outbytesleft < 4) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) ((ucs >> 24) & 0xff);
	out[1] = (unsigned char) ((ucs >> 16) & 0xff);
	out[2] = (unsigned char) ((ucs >> 8) & 0xff);
	out[3] = (unsigned char) (ucs & 0xff);
	
	(*chunk->outbuf) += 4;
	(*chunk->outbytesleft) -= 4;
		
	return 0;
}

static size_t miniconv_encode_utf32le(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned char *out;
	
	if (! miniconv_unicode_is_valid_code_point(ucs)) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}

	if (*chunk->outbytesleft < 4) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) (ucs & 0xff);
	out[1] = (unsigned char) ((ucs >> 8) & 0xff);
	out[2] = (unsigned char) ((ucs >> 16) & 0xff);
	out[3] = (unsigned char) ((ucs >> 24) & 0xff);
	
	(*chunk->outbuf) += 4;
	(*chunk->outbytesleft) -= 4;
		
	return 0;
}

static size_t miniconv_encode_utf32be(miniconv_chunk_t *chunk,
	miniconv_uint32_t ucs)
{
	unsigned char *out;

	if (! miniconv_unicode_is_valid_code_point(ucs)) {
		if (chunk->cd->mode == MINICONV_MODE_STRICT) {
			chunk->error = EILSEQ;
			return (size_t) -1;
		} else {
			return 1;
		}
	}
	
	if (*chunk->outbytesleft < 4) {
		chunk->error = E2BIG;
		return (size_t) -1;
	}
	
	out = (unsigned char *) *chunk->outbuf;
	out[0] = (unsigned char) ((ucs >> 24) & 0xff);
	out[1] = (unsigned char) ((ucs >> 16) & 0xff);
	out[2] = (unsigned char) ((ucs >> 8) & 0xff);
	out[3] = (unsigned char) (ucs & 0xff);
	
	(*chunk->outbuf) += 4;
	(*chunk->outbytesleft) -= 4;
		
	return 0;
}

/** @private */
typedef struct miniconv_codec_list_s {
	const char *name;
	miniconv_decoder_t decoder;
	miniconv_encoder_t encoder;
} miniconv_codec_list_t;

/* To add a new encoding simply write encoder and decoder functions and
   update the following array: */
static miniconv_codec_list_t codecs[] = {
	{ "ASCII", &miniconv_decode_ascii, &miniconv_encode_ascii },
	{ "UTF-8", &miniconv_decode_utf8, &miniconv_encode_utf8 },
	{ "ISO-8859-1", &miniconv_decode_ucs1, &miniconv_encode_ucs1 },
	{ "ISO-LATIN-1", &miniconv_decode_ucs1, &miniconv_encode_ucs1 },
	{ "LATIN-1", &miniconv_decode_ucs1, &miniconv_encode_ucs1 },
	{ "UCS-1", &miniconv_decode_ucs1, &miniconv_encode_ucs1 },
	{ "UCS-2LE", &miniconv_decode_ucs2le, &miniconv_encode_ucs2le },
	{ "UCS-2BE", &miniconv_decode_ucs2be, &miniconv_encode_ucs2be },
	{ "UTF-16LE", &miniconv_decode_utf16le, &miniconv_encode_utf16le },
	{ "UTF-16BE", &miniconv_decode_utf16be, &miniconv_encode_utf16be },
	{ "UCS-4LE", &miniconv_decode_ucs4le, &miniconv_encode_ucs4le },
	{ "UCS-4BE", &miniconv_decode_ucs4be, &miniconv_encode_ucs4be },
	{ "UTF-32LE", &miniconv_decode_utf32le, &miniconv_encode_utf32le },
	{ "UTF-32BE", &miniconv_decode_utf32be, &miniconv_encode_utf32be },
#ifdef __BIG_ENDIAN__
	{ "UCS-2-INTERNAL", &miniconv_decode_ucs2be, &miniconv_encode_ucs2be },
	{ "UTF-16-INTERNAL", &miniconv_decode_utf16be, &miniconv_encode_utf16be },
	{ "UCS-4-INTERNAL", &miniconv_decode_ucs4be, &miniconv_encode_ucs4be },
	{ "UTF-32-INTERNAL", &miniconv_decode_utf32be, &miniconv_encode_utf32be },
#else
	{ "UCS-2-INTERNAL", &miniconv_decode_ucs2le, &miniconv_encode_ucs2le },
	{ "UTF-16-INTERNAL", &miniconv_decode_utf16le, &miniconv_encode_utf16le },
	{ "UCS-4-INTERNAL", &miniconv_decode_ucs4le, &miniconv_encode_ucs4le },
	{ "UTF-32-INTERNAL", &miniconv_decode_utf32le, &miniconv_encode_utf32le },
#endif
	{ "ISO-8859-2", &miniconv_decode_iso_8859_2, NULL },
	{ "ISO-8859-3", &miniconv_decode_iso_8859_3, NULL },
	{ "ISO-8859-4", &miniconv_decode_iso_8859_4, NULL },
	{ "ISO-8859-5", &miniconv_decode_iso_8859_5, NULL },
	{ "ISO-8859-6", &miniconv_decode_iso_8859_6, NULL },
	{ "ISO-8859-7", &miniconv_decode_iso_8859_7, NULL },
	{ "ISO-8859-8", &miniconv_decode_iso_8859_8, NULL },
	{ "ISO-8859-9", &miniconv_decode_iso_8859_9, NULL },
	{ "ISO-8859-10", &miniconv_decode_iso_8859_10, NULL },
	{ "ISO-8859-11", &miniconv_decode_iso_8859_11, NULL },
	{ "ISO-8859-13", &miniconv_decode_iso_8859_13, NULL },
	{ "ISO-8859-14", &miniconv_decode_iso_8859_14, NULL },
	{ "ISO-8859-15", &miniconv_decode_iso_8859_15, NULL },
	{ "ISO-8859-16", &miniconv_decode_iso_8859_16, NULL },
	{ "WINDOWS-1250", &miniconv_decode_windows_cp1250, NULL },
	{ "WINDOWS-1251", &miniconv_decode_windows_cp1251, NULL },
	{ "WINDOWS-1252", &miniconv_decode_windows_cp1252, NULL },
	{ "WINDOWS-1253", &miniconv_decode_windows_cp1253, NULL },
	{ "WINDOWS-1254", &miniconv_decode_windows_cp1254, NULL },
	{ "WINDOWS-1255", &miniconv_decode_windows_cp1255, NULL },
	{ "WINDOWS-1256", &miniconv_decode_windows_cp1256, NULL },
	{ "WINDOWS-1257", &miniconv_decode_windows_cp1257, NULL },
	{ "WINDOWS-1258", &miniconv_decode_windows_cp1258, NULL },
	{ "WINDOWS-874", &miniconv_decode_windows_cp874, NULL },
	{ "CP1250", &miniconv_decode_windows_cp1250, NULL },
	{ "CP1251", &miniconv_decode_windows_cp1251, NULL },
	{ "CP1252", &miniconv_decode_windows_cp1252, NULL },
	{ "CP1253", &miniconv_decode_windows_cp1253, NULL },
	{ "CP1254", &miniconv_decode_windows_cp1254, NULL },
	{ "CP1255", &miniconv_decode_windows_cp1255, NULL },
	{ "CP1256", &miniconv_decode_windows_cp1256, NULL },
	{ "CP1257", &miniconv_decode_windows_cp1257, NULL },
	{ "CP1258", &miniconv_decode_windows_cp1258, NULL },
	{ "CP874", &miniconv_decode_windows_cp874, NULL },
};

static int miniconv_cmp(const char *a, const char *b)
{
	for (;;)
	{
		int d;
		
		/* Ignore '-' and '_' when comparing. */
		while (*a == '-' || *a == '_')
			++a;
		while (*b == '-' || *b == '_')
			++b;
		
		d = (int) (unsigned char) tolower(*a) -
			(int) (unsigned char) tolower(*b);
				
		if (d)
			return d;
			
		if (! *a)
			return 0;
			
		++a;
		++b;
	}
}

static miniconv_codec_list_t *miniconv_find_codec(const char *name)
{
	miniconv_codec_list_t *p, *e;
	
	p = codecs;
	e = codecs + COUNTOF(codecs);
	
	for (; p != e; p++) {
		if (miniconv_cmp(p->name, name) == 0)
			return p;
	}
	
	return 0;
}

miniconv_t miniconv_open2(const char *toenc, const char *fromenc,
	int *error)
{
	miniconv_cd_t *cd;
	miniconv_codec_list_t *codec;
	miniconv_decoder_t decoder;
	miniconv_encoder_t encoder;
	const char *slsl;
	char *toencdup = 0;
	
	slsl = strstr(toenc, "//");
	if (slsl) {
		toencdup = strdup(toenc);
		if (! toencdup) {
			*error = ENOMEM;
			goto fail;
		}
		toencdup[slsl - toenc] = '\0';
		toenc = toencdup;
	}
	
	codec = miniconv_find_codec(fromenc);
	if (! codec || ! codec->decoder) {
		*error = EINVAL;
		goto fail;
	}
	
	decoder = codec->decoder;
	
	codec = miniconv_find_codec(toenc);
	if (! codec || ! codec->encoder) {
		*error = EINVAL;
		goto fail;
	}
	
	encoder = codec->encoder;
	
	cd = (miniconv_cd_t *) malloc(sizeof(miniconv_cd_t));
	if (! cd) {
		*error = ENOMEM;
		goto fail;
	}

	cd->mode = MINICONV_MODE_STRICT;
	
	if (slsl) {
		if (strcmp(slsl, "//IGNORE") == 0)
			cd->mode = MINICONV_MODE_DISCARD;
		else if (strcmp(slsl, "//TRANSLIT") == 0)
			cd->mode = MINICONV_MODE_TRANSLIT;
	}

	cd->decoder = decoder;
	cd->encoder = encoder;
	
	free(toencdup);
	return (miniconv_t) cd;

fail:
	free(toencdup);
	return (miniconv_t) -1;
}

miniconv_t miniconv_open(const char *toenc, const char *fromenc)
{
	int error = errno;
	miniconv_t result = miniconv_open2(toenc, fromenc, &error);
	errno = error;
	return result;
}

size_t miniconv2(miniconv_t cd, const char **inbuf, size_t *inbytesleft,
	char **outbuf, size_t *outbytesleft, int *error)
{
	size_t result;
	miniconv_chunk_t chunk;
	miniconv_cd_t *cdstruct = (miniconv_cd_t *) cd;
	
	chunk.cd = cdstruct;
	chunk.inbuf = inbuf;
	chunk.inbytesleft = inbytesleft;
	chunk.outbuf = outbuf;
	chunk.outbytesleft = outbytesleft;
	chunk.error = 0;
	
	result = (*cdstruct->decoder)(&chunk, cdstruct->encoder);
	*error = chunk.error;
	
	if (result != (size_t) -1) {
		if (*inbytesleft != 0) {
			*error = EINVAL;
			result = (size_t) -1;
		}
	}
	
	return result;
}

size_t miniconv(miniconv_t cd, const char **inbuf, size_t *inbytesleft,
	char **outbuf, size_t *outbytesleft)
{
	int error = errno;
	size_t result = miniconv2(cd, inbuf, inbytesleft, outbuf, outbytesleft,
		&error);
	errno = error;
	return result;
}

int miniconv_close(miniconv_t cd)
{
	miniconv_cd_t *cdstruct = (miniconv_cd_t *) cd;
	
	free(cdstruct);
	return 0;
}

